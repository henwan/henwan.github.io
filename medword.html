<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedWord Showdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .board-cell {
            position: relative;
        }
        .board-cell > div {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
        }
        .tile {
            cursor: grab;
            user-select: none;
            touch-action: none;
        }
        .permanent-tile {
            cursor: help; /* Change cursor to indicate it's clickable for definition */
        }
        .dragging {
            opacity: 0.5;
            cursor: grabbing;
            z-index: 1000;
        }
        .letter-tile {
            background-color: #f5f5f5;
            border: 1px solid #dcdcdc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .bonus-2l { background-color: #a0d8f0; } /* Light Blue */
        .bonus-3l { background-color: #4a90e2; color: white; } /* Dark Blue */
        .bonus-2w { background-color: #f7caca; } /* Light Pink */
        .bonus-3w { background-color: #e66767; color: white; } /* Dark Red */
        .center-star { background-color: #f7caca; }
        .center-star::before { content: '★'; font-size: 1.5rem; color: #e66767; }
        #modal-backdrop {
            transition: opacity 0.3s ease-in-out;
        }
        #modal-content {
            transition: transform 0.3s ease-in-out;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div id="game-container" class="w-full max-w-7xl mx-auto hidden">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-teal-700 mb-4">MedWord Showdown</h1>

        <div class="flex flex-col lg:flex-row gap-4">
            <!-- Left Panel: Game Board -->
            <div class="w-full lg:w-2/3">
                <div id="game-board" class="grid gap-0.5 bg-gray-300 rounded-lg p-1 shadow-lg aspect-square">
                    <!-- Board cells will be generated by JS -->
                </div>
            </div>

            <!-- Right Panel: Controls, Info, Score -->
            <div class="w-full lg:w-1/3 flex flex-col gap-4">
                <div id="game-info" class="bg-white p-4 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-2 text-gray-700">Game Info</h2>
                    <div class="flex items-center">
                        <p class="mr-2">Game ID:</p>
                        <input type="text" id="gameIdDisplay" readonly class="flex-grow bg-gray-200 p-2 rounded-l-md focus:outline-none">
                        <button id="copyGameIdBtn" class="bg-teal-600 text-white px-4 py-2 rounded-r-md hover:bg-teal-700 transition-colors">Copy</button>
                    </div>
                     <p class="mt-2 text-sm text-gray-600">Share this ID with colleagues to join the game.</p>
                     <div id="turn-indicator" class="mt-4 text-lg font-medium text-center p-2 rounded-md bg-yellow-100 text-yellow-800">
                        Initializing...
                    </div>
                </div>

                <div id="score-board" class="bg-white p-4 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-2 text-gray-700">Scoreboard</h2>
                    <div id="player-scores" class="space-y-2">
                        <!-- Player scores will be generated by JS -->
                    </div>
                </div>

                <div id="player-controls" class="bg-white p-4 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-2 text-gray-700">Your Tiles</h2>
                    <div id="tile-rack" class="flex justify-center items-center gap-1 bg-gray-200 p-2 rounded-md min-h-[60px] mb-4">
                        <!-- Player tiles will be generated by JS -->
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="play-word-btn" class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 transition-colors disabled:bg-gray-400">Play Word</button>
                        <button id="pass-turn-btn" class="w-full bg-orange-500 text-white py-2 px-4 rounded-md hover:bg-orange-600 transition-colors disabled:bg-gray-400">Pass Turn</button>
                        <button id="shuffle-tiles-btn" class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition-colors disabled:bg-gray-400">Shuffle</button>
                        <button id="recall-tiles-btn" class="w-full bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600 transition-colors">Recall Tiles</button>
                    </div>
                     <button id="ai-hint-btn" class="w-full mt-2 bg-purple-600 text-white py-2 px-4 rounded-md hover:bg-purple-700 transition-colors disabled:bg-gray-400">✨ AI Hint</button>
                </div>
                 <div class="bg-white p-4 rounded-lg shadow-md">
                    <p id="dictionary-status" class="text-center text-gray-600">Initializing medical dictionary...</p>
                    <p id="tiles-left" class="text-center font-medium text-lg mt-2">Tiles in Bag: --</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobby-screen" class="w-full max-w-md mx-auto bg-white p-8 rounded-xl shadow-2xl text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-teal-700 mb-2">MedWord Showdown</h1>
        <p class="text-gray-600 mb-8">The word game for medical professionals.</p>
        <div class="space-y-4">
            <button id="create-game-btn" class="w-full bg-teal-600 text-white py-3 px-6 rounded-lg text-lg font-semibold hover:bg-teal-700 transition-transform transform hover:scale-105">Create New Game</button>
            <div class="relative flex py-5 items-center">
                <div class="flex-grow border-t border-gray-300"></div>
                <span class="flex-shrink mx-4 text-gray-500">OR</span>
                <div class="flex-grow border-t border-gray-300"></div>
            </div>
            <div class="flex">
                <input type="text" id="join-game-input" placeholder="Enter Game ID" class="w-full p-3 border border-gray-300 rounded-l-lg focus:ring-2 focus:ring-teal-500 focus:outline-none">
                <button id="join-game-btn" class="bg-blue-600 text-white py-3 px-6 rounded-r-lg font-semibold hover:bg-blue-700 transition-colors">Join Game</button>
            </div>
        </div>
        <p id="lobby-error" class="text-red-500 mt-4 h-5"></p>
    </div>

    <!-- Custom Modal -->
    <div id="modal-backdrop" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div id="modal-content" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm text-center transform scale-95">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Game Over</h3>
            <div id="modal-body">
                <p id="modal-message" class="text-gray-700 mb-6">Player X wins!</p>
            </div>
            <button id="modal-close-btn" class="bg-teal-600 text-white py-2 px-8 rounded-lg hover:bg-teal-700 transition-colors">Close</button>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONFIG AND STATE ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'medword-showdown';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId;
        let currentGameId = null;
        let localGameState = null;
        let unsubscribeGameListener = null;
        let medicalDictionary = new Set();

        // Game constants
        const BOARD_SIZE = 15;
        const TILE_RACK_SIZE = 7;
        const TILE_DISTRIBUTION = {
            'A': { count: 9, value: 1 }, 'B': { count: 2, value: 3 }, 'C': { count: 2, value: 3 },
            'D': { count: 4, value: 2 }, 'E': { count: 12, value: 1 }, 'F': { count: 2, value: 4 },
            'G': { count: 3, value: 2 }, 'H': { count: 2, value: 4 }, 'I': { count: 9, value: 1 },
            'J': { count: 1, value: 8 }, 'K': { count: 1, value: 5 }, 'L': { count: 4, value: 1 },
            'M': { count: 2, value: 3 }, 'N': { count: 6, value: 1 }, 'O': { count: 8, value: 1 },
            'P': { count: 2, value: 3 }, 'Q': { count: 1, value: 10 }, 'R': { count: 6, value: 1 },
            'S': { count: 4, value: 1 }, 'T': { count: 6, value: 1 }, 'U': { count: 4, value: 1 },
            'V': { count: 2, value: 4 }, 'W': { count: 2, value: 4 }, 'X': { count: 1, value: 8 },
            'Y': { count: 2, value: 4 }, 'Z': { count: 1, value: 10 }
        };
        const BONUS_SQUARES = {
            '0,0': '3w', '0,7': '3w', '0,14': '3w', '7,0': '3w', '7,14': '3w', '14,0': '3w', '14,7': '3w', '14,14': '3w',
            '1,1': '2w', '2,2': '2w', '3,3': '2w', '4,4': '2w', '1,13': '2w', '2,12': '2w', '3,11': '2w', '4,10': '2w',
            '10,4': '2w', '11,3': '2w', '12,2': '2w', '13,1': '2w', '10,10': '2w', '11,11': '2w', '12,12': '2w', '13,13': '2w',
            '1,5': '3l', '1,9': '3l', '5,1': '3l', '5,5': '3l', '5,9': '3l', '5,13': '3l', '9,1': '3l', '9,5': '3l', '9,9': '3l', '9,13': '3l', '13,5': '3l', '13,9': '3l',
            '0,3': '2l', '0,11': '2l', '2,6': '2l', '2,8': '2l', '3,0': '2l', '3,7': '2l', '3,14': '2l', '6,2': '2l', '6,6': '2l', '6,8': '2l', '6,12': '2l',
            '7,3': '2l', '7,11': '2l', '8,2': '2l', '8,6': '2l', '8,8': '2l', '8,12': '2l', '11,0': '2l', '11,7': '2l', '11,14': '2l', '12,6': '2l', '12,8': '2l', '14,3': '2l', '14,11': '2l'
        };

        // --- UI ELEMENTS ---
        const gameContainer = document.getElementById('game-container');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameBoard = document.getElementById('game-board');
        const tileRack = document.getElementById('tile-rack');
        const playWordBtn = document.getElementById('play-word-btn');
        const passTurnBtn = document.getElementById('pass-turn-btn');
        const shuffleTilesBtn = document.getElementById('shuffle-tiles-btn');
        const recallTilesBtn = document.getElementById('recall-tiles-btn');
        const aiHintBtn = document.getElementById('ai-hint-btn');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameBtn = document.getElementById('join-game-btn');
        const joinGameInput = document.getElementById('join-game-input');
        const gameIdDisplay = document.getElementById('gameIdDisplay');
        const copyGameIdBtn = document.getElementById('copyGameIdBtn');
        const playerScoresContainer = document.getElementById('player-scores');
        const turnIndicator = document.getElementById('turn-indicator');
        const tilesLeftDisplay = document.getElementById('tiles-left');
        const lobbyError = document.getElementById('lobby-error');
        const dictionaryStatus = document.getElementById('dictionary-status');

        // Modal elements
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // --- DRAG AND DROP STATE ---
        let draggedTile = null;
        let placedTiles = []; // { letter, value, originalRackIndex, row, col, element }

        // --- INITIALIZATION ---
        window.onload = async () => {
            await authenticateUser();
            initializeDictionary();
            setupLobbyListeners();
            setupGameBoard();
            setupControlListeners();
        };

        async function authenticateUser() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                lobbyError.textContent = "Could not connect. Please refresh.";
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                } else {
                    console.error("User is not signed in.");
                }
            });
        }
        
        function initializeDictionary() {
            dictionaryStatus.textContent = 'Loading medical dictionary...';
            const staticMedicalWords = [
                'ACNE', 'AORTA', 'ATRIUM', 'AXON', 'BILE', 'BIOPSY', 'BLOOD', 'BONE',
                'BRAIN', 'BRONCHI', 'CANCER', 'CELL', 'CLOT', 'COLON', 'CORNEA', 'COMA',
                'CYST', 'DENTAL', 'DERMA', 'DNA', 'DUCT', 'DRUG', 'EDEMA', 'ENZYME',
                'FEMUR', 'FETUS', 'FEVER', 'FIBULA', 'GENE', 'GLAND', 'GUT', 'HEART',
                'HERNIA', 'HORMONE', 'HOST', 'HYPOXIA', 'IRIS', 'JOINT', 'KELOID',
                'KIDNEY', 'LARYNX', 'LASER', 'LENS', 'LIVER', 'LOBE', 'LUNG', 'LYMPH',
                'MEDIC', 'MOLAR', 'MUCOUS', 'MUSCLE', 'NERVE', 'NEURON', 'NODE', 'ORGAN',
                'OVARY', 'PALATE', 'PANCREAS', 'PELVIS', 'PHLEGM', 'PLASMA', 'PLATELET',
                'POLLEN', 'PROBE', 'PULSE', 'PUPIL', 'RECTUM', 'RETINA', 'RNA', 'SCAB',
                'SCALP', 'SCAN', 'SCOLIOSIS', 'SEIZURE', 'SERUM', 'SINUS', 'SKIN', 'SKULL',
                'SPASM', 'SPINE', 'SPLEEN', 'SPORE', 'STENT', 'STOMACH', 'SUTURE', 'SYNAPSE',
                'TENDON', 'TESTIS', 'THROAT', 'THYMUS', 'THYROID', 'TIBIA', 'TISSUE',
                'TONSIL', 'TOXIN', 'TRACHEA', 'TUMOR', 'ULCER', 'ULNA', 'UREA', 'URETER',
                'UTERUS', 'UVULA', 'VACCINE', 'VEIN', 'VENTRICLE', 'VIRUS', 'VITAMIN', 'VOMIT',
                'WOMB', 'XRAY', 'YEAST', 'ZINC', 'ZYGOTE'
            ];
            medicalDictionary = new Set(staticMedicalWords);
            dictionaryStatus.textContent = `Medical Dictionary Ready (${medicalDictionary.size} terms)`;
        }

        // --- LOBBY LOGIC ---
        function setupLobbyListeners() {
            createGameBtn.addEventListener('click', createNewGame);
            joinGameBtn.addEventListener('click', joinExistingGame);
            copyGameIdBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(gameIdDisplay.value).then(() => {
                    copyGameIdBtn.textContent = 'Copied!';
                    setTimeout(() => { copyGameIdBtn.textContent = 'Copy'; }, 2000);
                });
            });
        }

        async function createNewGame() {
            if (!userId) {
                lobbyError.textContent = "User not authenticated.";
                return;
            }
            const newGameId = generateGameId();
            const gameRef = doc(db, "artifacts", appId, "public/data/medword", newGameId);
            
            const tileBag = createTileBag();
            const initialPlayer = {
                id: userId,
                score: 0,
                tiles: drawTiles(tileBag, TILE_RACK_SIZE),
                passCount: 0,
            };

            const newGameState = {
                gameId: newGameId,
                board: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
                tileBag: tileBag,
                players: [initialPlayer],
                currentPlayerIndex: 0,
                gameOver: false,
                turnLog: [`Game created by Player 1 (${userId.substring(0,5)})`],
                createdAt: serverTimestamp()
            };

            try {
                await setDoc(gameRef, newGameState);
                await switchToGameView(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                lobbyError.textContent = "Failed to create game.";
            }
        }

        async function joinExistingGame() {
            const gameIdToJoin = joinGameInput.value.trim();
            if (!gameIdToJoin) {
                lobbyError.textContent = "Please enter a Game ID.";
                return;
            }
            if (!userId) {
                lobbyError.textContent = "User not authenticated.";
                return;
            }

            const gameRef = doc(db, "artifacts", appId, "public/data/medword", gameIdToJoin);
            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) {
                    lobbyError.textContent = "Game not found.";
                    return;
                }

                const gameData = gameSnap.data();
                if (gameData.players.find(p => p.id === userId)) {
                    // Player is already in the game, just rejoin
                    await switchToGameView(gameIdToJoin);
                    return;
                }

                if (gameData.players.length >= 4) {
                    lobbyError.textContent = "Game is full (max 4 players).";
                    return;
                }

                const newPlayer = {
                    id: userId,
                    score: 0,
                    tiles: drawTiles(gameData.tileBag, TILE_RACK_SIZE),
                    passCount: 0,
                };

                const updatedPlayers = [...gameData.players, newPlayer];
                const updatedLog = [...gameData.turnLog, `Player ${updatedPlayers.length} (${userId.substring(0,5)}) joined.`];

                await updateDoc(gameRef, {
                    players: updatedPlayers,
                    tileBag: gameData.tileBag,
                    turnLog: updatedLog
                });

                await switchToGameView(gameIdToJoin);

            } catch (error) {
                console.error("Error joining game:", error);
                lobbyError.textContent = "Failed to join game.";
            }
        }

        async function switchToGameView(gameId) {
            currentGameId = gameId;
            lobbyScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameIdDisplay.value = gameId;

            if (unsubscribeGameListener) {
                unsubscribeGameListener();
            }
            const gameRef = doc(db, "artifacts", appId, "public/data/medword", gameId);
            unsubscribeGameListener = onSnapshot(gameRef, (doc) => {
                if (doc.exists()) {
                    localGameState = doc.data();
                    renderGame();
                } else {
                    console.error("Game data not found!");
                    // Handle game deletion, maybe return to lobby
                }
            });
        }

        // --- GAME STATE & RENDERING ---
        function renderGame() {
            if (!localGameState) return;
            
            renderBoard(localGameState.board);
            const myPlayerState = localGameState.players.find(p => p.id === userId);
            if (myPlayerState) {
                renderTileRack(myPlayerState.tiles);
            }
            renderScores(localGameState.players);
            updateTurnIndicator();
            updateControls();
            
            tilesLeftDisplay.textContent = `Tiles in Bag: ${localGameState.tileBag.length}`;

            if (localGameState.gameOver) {
                showModal("Game Over", `<p>${getEndGameMessage()}</p>`);
            }
        }

        function renderBoard(boardState) {
            // Clear existing word click listeners before re-rendering
            document.querySelectorAll('.permanent-tile').forEach(tile => {
                tile.removeEventListener('click', handleWordDefinitionClick);
            });

            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const row = Math.floor(i / BOARD_SIZE);
                const col = i % BOARD_SIZE;
                const cell = document.getElementById(`cell-${row}-${col}`);
                const cellContent = cell.querySelector('div');
                
                const existingTile = cellContent.querySelector('.letter-tile');
                if (existingTile) {
                    cellContent.removeChild(existingTile);
                }

                const tileData = boardState[i];
                if (tileData) {
                    const tileDiv = createTileElement(tileData.letter, tileData.value, false);
                    tileDiv.classList.remove('cursor-grab');
                    tileDiv.classList.add('permanent-tile');
                    tileDiv.dataset.row = row;
                    tileDiv.dataset.col = col;
                    tileDiv.addEventListener('click', handleWordDefinitionClick);
                    cellContent.appendChild(tileDiv);
                }
            }
        }

        function renderTileRack(tiles) {
            tileRack.innerHTML = '';
            tiles.forEach((tile, index) => {
                if (tile) {
                    const tileDiv = createTileElement(tile.letter, tile.value, true, index);
                    tileRack.appendChild(tileDiv);
                }
            });
        }
        
        function renderScores(players) {
            playerScoresContainer.innerHTML = '';
            players.forEach((player, index) => {
                const isMyTurn = index === localGameState.currentPlayerIndex;
                const isMe = player.id === userId;
                const scoreDiv = document.createElement('div');
                scoreDiv.className = `flex justify-between items-center p-2 rounded-md transition-all ${isMyTurn ? 'bg-teal-100 border-2 border-teal-500' : 'bg-gray-50'} ${isMe ? 'font-bold' : ''}`;
                scoreDiv.innerHTML = `
                    <span>Player ${index + 1} ${isMe ? '(You)' : `(${player.id.substring(0,5)})`}</span>
                    <span class="text-lg font-semibold">${player.score}</span>
                `;
                playerScoresContainer.appendChild(scoreDiv);
            });
        }

        function updateTurnIndicator() {
            if (!localGameState || localGameState.gameOver) {
                turnIndicator.textContent = 'Game Over';
                turnIndicator.className = 'mt-4 text-lg font-medium text-center p-2 rounded-md bg-gray-200 text-gray-800';
                return;
            }
            const currentPlayerIndex = localGameState.currentPlayerIndex;
            const currentPlayer = localGameState.players[currentPlayerIndex];
            if (currentPlayer.id === userId) {
                turnIndicator.textContent = "It's Your Turn!";
                turnIndicator.className = 'mt-4 text-lg font-medium text-center p-2 rounded-md bg-green-100 text-green-800 animate-pulse';
            } else {
                turnIndicator.textContent = `Waiting for Player ${currentPlayerIndex + 1}...`;
                turnIndicator.className = 'mt-4 text-lg font-medium text-center p-2 rounded-md bg-yellow-100 text-yellow-800';
            }
        }
        
        function updateControls() {
            const isMyTurn = localGameState && localGameState.players[localGameState.currentPlayerIndex].id === userId && !localGameState.gameOver;
            playWordBtn.disabled = !isMyTurn;
            passTurnBtn.disabled = !isMyTurn;
            shuffleTilesBtn.disabled = !isMyTurn;
            aiHintBtn.disabled = !isMyTurn;
        }

        // --- GAME BOARD & TILE CREATION ---
        function setupGameBoard() {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.id = `cell-${row}-${col}`;

                    const content = document.createElement('div');
                    content.className = 'border border-gray-400';
                    const key = `${row},${col}`;
                    if (row === 7 && col === 7) {
                        content.classList.add('center-star');
                    } else if (BONUS_SQUARES[key]) {
                        const bonus = BONUS_SQUARES[key];
                        content.classList.add(`bonus-${bonus}`);
                        content.textContent = bonus.toUpperCase();
                    } else {
                        content.classList.add('bg-green-50');
                    }
                    
                    cell.appendChild(content);
                    gameBoard.appendChild(cell);

                    // Drop target event listeners
                    cell.addEventListener('dragover', (e) => e.preventDefault());
                    cell.addEventListener('drop', (e) => onDrop(e, row, col));
                }
            }
        }

        function createTileElement(letter, value, isDraggable = false, rackIndex = -1) {
            const tileDiv = document.createElement('div');
            tileDiv.className = 'tile letter-tile w-10 h-10 md:w-12 md:h-12 flex items-center justify-center rounded-md text-xl font-bold relative';
            tileDiv.innerHTML = `
                ${letter}
                <span class="absolute bottom-0 right-1 text-xs font-medium">${value}</span>
            `;
            if (isDraggable) {
                tileDiv.draggable = true;
                tileDiv.dataset.letter = letter;
                tileDiv.dataset.value = value;
                tileDiv.dataset.rackIndex = rackIndex;
                tileDiv.addEventListener('dragstart', onDragStart);
                tileDiv.addEventListener('dragend', onDragEnd);
            }
            return tileDiv;
        }

        // --- DRAG & DROP HANDLERS ---
        function onDragStart(e) {
            draggedTile = {
                element: e.target,
                letter: e.target.dataset.letter,
                value: parseInt(e.target.dataset.value),
                originalRackIndex: parseInt(e.target.dataset.rackIndex)
            };
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function onDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedTile = null;
        }

        function onDrop(e, row, col) {
            e.preventDefault();
            if (!draggedTile) return;

            const cell = document.getElementById(`cell-${row}-${col}`);
            const cellContent = cell.querySelector('div');
            
            if (cellContent.querySelector('.letter-tile') || localGameState.board[row * BOARD_SIZE + col]) {
                return;
            }

            const newPlacedTile = {
                ...draggedTile,
                row,
                col
            };
            placedTiles.push(newPlacedTile);
            
            cellContent.appendChild(draggedTile.element);
            draggedTile.element.style.cursor = 'pointer';
            draggedTile.element.addEventListener('click', returnTileToRack);

            draggedTile = null;
        }
        
        // --- CONTROL BUTTON LOGIC ---
        function setupControlListeners() {
            recallTilesBtn.addEventListener('click', recallPlacedTiles);
            playWordBtn.addEventListener('click', handlePlayWord);
            passTurnBtn.addEventListener('click', handlePassTurn);
            shuffleTilesBtn.addEventListener('click', handleShuffle);
            aiHintBtn.addEventListener('click', handleAiHint);
            modalCloseBtn.addEventListener('click', () => modalBackdrop.classList.add('hidden'));
        }

        function returnTileToRack(e) {
            const tileElement = e.currentTarget;
            const tileIndex = placedTiles.findIndex(t => t.element === tileElement);
            if (tileIndex === -1) return;

            placedTiles.splice(tileIndex, 1);
            tileRack.appendChild(tileElement);
            tileElement.removeEventListener('click', returnTileToRack);
            tileElement.style.cursor = 'grab';
        }

        function recallPlacedTiles() {
            while (placedTiles.length > 0) {
                const tileData = placedTiles[0];
                returnTileToRack({ currentTarget: tileData.element });
            }
        }

        async function handlePlayWord() {
            if (placedTiles.length === 0) {
                showModal("Invalid Move", "<p>You must place at least one tile.</p>");
                return;
            }

            const validationResult = validateMove(placedTiles, localGameState.board);
            if (!validationResult.isValid) {
                showModal("Invalid Move", `<p>${validationResult.message}</p>`);
                return;
            }

            const scoreResult = calculateScore(validationResult.words, localGameState.board);
            
            const newBoard = [...localGameState.board];
            placedTiles.forEach(tile => {
                newBoard[tile.row * BOARD_SIZE + tile.col] = { letter: tile.letter, value: tile.value };
            });

            const myPlayer = localGameState.players.find(p => p.id === userId);
            const myPlayerIndex = localGameState.players.findIndex(p => p.id === userId);
            
            const usedRackIndices = new Set(placedTiles.map(t => t.originalRackIndex));
            const remainingTiles = myPlayer.tiles.filter((_, index) => !usedRackIndices.has(index));
            
            const newTiles = drawTiles(localGameState.tileBag, placedTiles.length);
            const updatedHand = [...remainingTiles, ...newTiles];

            const updatedPlayer = {
                ...myPlayer,
                score: myPlayer.score + scoreResult.totalScore,
                tiles: updatedHand,
                passCount: 0
            };
            
            const updatedPlayers = [...localGameState.players];
            updatedPlayers[myPlayerIndex] = updatedPlayer;

            const nextPlayerIndex = (localGameState.currentPlayerIndex + 1) % localGameState.players.length;
            
            const wordStrings = validationResult.words.map(w => w.map(t => t.letter).join('')).join(', ');
            const newLog = [...localGameState.turnLog, `Player ${myPlayerIndex+1} played ${wordStrings} for ${scoreResult.totalScore} points.`];
            
            let gameOver = false;
            let endGameReason = "";
            if (updatedHand.length === 0 && localGameState.tileBag.length === 0) {
                gameOver = true;
                endGameReason = `Player ${myPlayerIndex + 1} used all their tiles!`;
            }

            const updates = {
                board: newBoard,
                players: updatedPlayers,
                tileBag: localGameState.tileBag,
                currentPlayerIndex: nextPlayerIndex,
                turnLog: newLog,
                gameOver: gameOver
            };
            
            if (gameOver) {
                const finalUpdates = finalizeScores(updates.players, myPlayerIndex);
                updates.players = finalUpdates.players;
                updates.turnLog.push(endGameReason, ...finalUpdates.logMessages);
            }

            const gameRef = doc(db, "artifacts", appId, "public/data/medword", currentGameId);
            try {
                placedTiles.forEach(t => t.element.removeEventListener('click', returnTileToRack));
                await updateDoc(gameRef, updates);
                placedTiles = [];
            } catch (error) {
                console.error("Error updating game state:", error);
                showModal("Error", "<p>Could not submit your move. Please try again.</p>");
                placedTiles.forEach(t => t.element.addEventListener('click', returnTileToRack));
            }
        }
        
        async function handlePassTurn() {
            const myPlayerIndex = localGameState.players.findIndex(p => p.id === userId);
            const updatedPlayers = [...localGameState.players];
            updatedPlayers[myPlayerIndex].passCount = (updatedPlayers[myPlayerIndex].passCount || 0) + 1;
            
            const nextPlayerIndex = (localGameState.currentPlayerIndex + 1) % localGameState.players.length;
            const newLog = [...localGameState.turnLog, `Player ${myPlayerIndex+1} passed their turn.`];
            
            let gameOver = updatedPlayers.every(p => p.passCount >= 2);
            if (gameOver) {
                newLog.push("Game over: All players passed twice.");
                const finalUpdates = finalizeScores(updatedPlayers, -1);
                updatedPlayers = finalUpdates.players;
                newLog.push(...finalUpdates.logMessages);
            }

            const updates = {
                players: updatedPlayers,
                currentPlayerIndex: nextPlayerIndex,
                turnLog: newLog,
                gameOver: gameOver
            };
            
            const gameRef = doc(db, "artifacts", appId, "public/data/medword", currentGameId);
            await updateDoc(gameRef, updates);
        }
        
        async function handleShuffle() {
            const myPlayer = localGameState.players.find(p => p.id === userId);
            const myPlayerIndex = localGameState.players.findIndex(p => p.id === userId);
            
            if (localGameState.tileBag.length < myPlayer.tiles.length) {
                showModal("Shuffle Not Possible", "<p>Not enough tiles in the bag to shuffle.</p>");
                return;
            }
            
            const newTileBag = [...localGameState.tileBag, ...myPlayer.tiles];
            shuffleArray(newTileBag);
            
            const newHand = drawTiles(newTileBag, TILE_RACK_SIZE);
            
            const updatedPlayer = { ...myPlayer, tiles: newHand, passCount: 0 };
            const updatedPlayers = [...localGameState.players];
            updatedPlayers[myPlayerIndex] = updatedPlayer;
            
            const nextPlayerIndex = (localGameState.currentPlayerIndex + 1) % localGameState.players.length;
            const newLog = [...localGameState.turnLog, `Player ${myPlayerIndex+1} shuffled their tiles.`];
            
            const updates = {
                tileBag: newTileBag,
                players: updatedPlayers,
                currentPlayerIndex: nextPlayerIndex,
                turnLog: newLog
            };
            
            const gameRef = doc(db, "artifacts", appId, "public/data/medword", currentGameId);
            await updateDoc(gameRef, updates);
        }

        // --- GEMINI API FEATURES ---
        async function handleAiHint() {
            showModal("✨ AI Word Finder", `<div class="spinner"></div><p>Consulting with the AI specialist...</p>`);
            
            const myPlayer = localGameState.players.find(p => p.id === userId);
            const playerTiles = myPlayer.tiles.map(t => t.letter).join('');
            
            let boardString = "The board is 15x15. '.' represents an empty square.\n";
            for (let r = 0; r < BOARD_SIZE; r++) {
                let rowStr = "";
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = localGameState.board[r * BOARD_SIZE + c];
                    rowStr += tile ? tile.letter : ".";
                }
                boardString += rowStr + "\n";
            }

            const prompt = `You are an expert medical Scrabble player. Your task is to find a valid, high-scoring word.
            - Player's tiles: ${playerTiles}
            - Dictionary: ${[...medicalDictionary].slice(0, 50).join(', ')}... (sample)
            - Board state:\n${boardString}
            Analyze the board and the player's tiles to suggest one good move. Be concise. For example: 'Try playing VIRUS starting at row 5, column 8.'`;

            try {
                const resultText = await callGemini(prompt);
                showModal("✨ AI Word Finder", `<p class="text-left">${resultText.replace(/\n/g, '<br>')}</p>`);
            } catch (error) {
                showModal("✨ AI Error", `<p>The AI specialist is unavailable. Please try again later.</p>`);
                console.error("AI Hint Error:", error);
            }
        }

        async function handleWordDefinitionClick(e) {
            const tileElement = e.currentTarget;
            const row = parseInt(tileElement.dataset.row);
            const col = parseInt(tileElement.dataset.col);

            const { word } = findWordAt(row, col, localGameState.board);
            if (!word) return;

            showModal(`Define: ${word}`, `<div class="spinner"></div><p>Looking up "${word}"...</p>`);

            const prompt = `Provide a simple, one-sentence medical definition for the word "${word}".`;
            try {
                const definition = await callGemini(prompt);
                showModal(`Define: ${word}`, `<p class="text-left">${definition}</p>`);
            } catch (error) {
                showModal("Definition Error", `<p>Could not retrieve a definition for "${word}".</p>`);
                console.error("Definition Error:", error);
            }
        }

        async function callGemini(prompt) {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }

            const result = await response.json();
            if (result.candidates && result.candidates[0].content.parts[0].text) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error("Invalid API response structure.");
            }
        }


        // --- GAME LOGIC: VALIDATION & SCORING ---
        function validateMove(newTiles, board) {
            if (newTiles.length === 0) return { isValid: false, message: "No tiles played." };

            const isFirstMove = board.every(cell => cell === null);
            if (isFirstMove) {
                if (!newTiles.some(t => t.row === 7 && t.col === 7)) {
                    return { isValid: false, message: "First word must cover the center star." };
                }
            } else {
                if (!newTiles.some(t => hasAdjacentTile(t.row, t.col, board))) {
                    return { isValid: false, message: "New words must connect to existing tiles." };
                }
            }

            const allTilesOnBoard = newTiles.map(t => ({...t, onBoard: false }));
            const moveAxis = getMoveAxis(newTiles);
            if (moveAxis === 'invalid') {
                return { isValid: false, message: "Tiles must be in a single row or column." };
            }

            const mainWordTiles = getMainWord(allTilesOnBoard, moveAxis, board);
            const mainWordString = mainWordTiles.map(t => t.letter).join('');
            if (!medicalDictionary.has(mainWordString)) {
                 return { isValid: false, message: `"${mainWordString}" is not a valid medical term.` };
            }
            if (mainWordTiles.length < 2) {
                return { isValid: false, message: "Words must be at least 2 letters long." };
            }

            const allWords = [mainWordTiles];
            const crossWords = getCrossWords(allTilesOnBoard, moveAxis, board);

            for (const word of crossWords) {
                const wordString = word.map(t => t.letter).join('');
                if (!medicalDictionary.has(wordString)) {
                    return { isValid: false, message: `"${wordString}" is not a valid medical term.` };
                }
                allWords.push(word);
            }

            return { isValid: true, words: allWords };
        }
        
        function calculateScore(words, board) {
            let totalScore = 0;
            let mainWord = words[0];
            let wordMultiplier = 1;
            let wordScore = 0;

            mainWord.forEach(tile => {
                let letterScore = tile.value;
                if (!tile.onBoard) {
                    const key = `${tile.row},${tile.col}`;
                    const bonus = BONUS_SQUARES[key] || (tile.row === 7 && tile.col === 7 ? '2w' : null);
                    if (bonus === '2l') letterScore *= 2;
                    if (bonus === '3l') letterScore *= 3;
                    if (bonus === '2w') wordMultiplier *= 2;
                    if (bonus === '3w') wordMultiplier *= 3;
                }
                wordScore += letterScore;
            });
            totalScore += wordScore * wordMultiplier;

            for (let i = 1; i < words.length; i++) {
                let crossWord = words[i];
                let crossWordScore = 0;
                let crossWordMultiplier = 1;
                crossWord.forEach(tile => {
                    let letterScore = tile.value;
                     if (!tile.onBoard) {
                        const key = `${tile.row},${tile.col}`;
                        const bonus = BONUS_SQUARES[key] || (tile.row === 7 && tile.col === 7 ? '2w' : null);
                        if (bonus === '2l') letterScore *= 2;
                        if (bonus === '3l') letterScore *= 3;
                        if (bonus === '2w') crossWordMultiplier *= 2;
                        if (bonus === '3w') crossWordMultiplier *= 3;
                    }
                    crossWordScore += letterScore;
                });
                totalScore += crossWordScore * crossWordMultiplier;
            }
            
            const newTilesCount = mainWord.filter(t => !t.onBoard).length;
            if (newTilesCount === TILE_RACK_SIZE) {
                totalScore += 50;
            }

            return { totalScore };
        }
        
        function finalizeScores(players, playerWhoWentOutIndex) {
            let logMessages = [];
            if (playerWhoWentOutIndex !== -1) {
                let pointsFromOthers = 0;
                players.forEach((player, index) => {
                    if (index !== playerWhoWentOutIndex) {
                        const remainingValue = player.tiles.reduce((sum, tile) => sum + (tile ? tile.value : 0), 0);
                        player.score -= remainingValue;
                        pointsFromOthers += remainingValue;
                        if (remainingValue > 0) logMessages.push(`Player ${index + 1} loses ${remainingValue} points for remaining tiles.`);
                    }
                });
                players[playerWhoWentOutIndex].score += pointsFromOthers;
                if (pointsFromOthers > 0) logMessages.push(`Player ${playerWhoWentOutIndex + 1} gains ${pointsFromOthers} points.`);
            }
            return { players, logMessages };
        }

        function getEndGameMessage() {
            if (!localGameState || !localGameState.players) return "The game has ended.";
            const sortedPlayers = [...localGameState.players].sort((a, b) => b.score - a.score);
            let message = "<strong>Final Scores:</strong><br>";
            sortedPlayers.forEach((p, i) => {
                const playerIndex = localGameState.players.findIndex(orig => orig.id === p.id) + 1;
                message += `${i === 0 ? '🏆' : ''} Player ${playerIndex}: ${p.score} points<br>`;
            });
            return message;
        }

        // --- UTILITY FUNCTIONS ---
        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createTileBag() {
            const bag = [];
            for (const letter in TILE_DISTRIBUTION) {
                for (let i = 0; i < TILE_DISTRIBUTION[letter].count; i++) {
                    bag.push({ letter, value: TILE_DISTRIBUTION[letter].value });
                }
            }
            shuffleArray(bag);
            return bag;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function drawTiles(tileBag, count) {
            const drawn = [];
            for (let i = 0; i < count; i++) {
                if (tileBag.length > 0) {
                    drawn.push(tileBag.pop());
                }
            }
            return drawn;
        }
        
        function showModal(title, contentHtml) {
            modalTitle.textContent = title;
            modalBody.innerHTML = contentHtml;
            modalBackdrop.classList.remove('hidden');
            modalContent.classList.remove('scale-95');
            modalContent.classList.add('scale-100');
        }

        // --- WORD FINDING HELPERS ---
        function getTileAt(row, col, newTiles, board) {
            const newTile = newTiles.find(t => t.row === row && t.col === col);
            if (newTile) return { ...newTile, onBoard: false };
            const boardIndex = row * BOARD_SIZE + col;
            if (board[boardIndex]) return { ...board[boardIndex], row, col, onBoard: true };
            return null;
        }

        function findWordAt(row, col, board) {
            const tile = board[row * BOARD_SIZE + col];
            if (!tile) return { word: null, tiles: [] };

            // Check for horizontal word
            let startCol = col;
            while (startCol > 0 && board[row * BOARD_SIZE + (startCol - 1)]) {
                startCol--;
            }
            let endCol = col;
            while (endCol < BOARD_SIZE - 1 && board[row * BOARD_SIZE + (endCol + 1)]) {
                endCol++;
            }

            if (startCol !== endCol) { // It's a horizontal word
                let word = "";
                for (let c = startCol; c <= endCol; c++) {
                    word += board[row * BOARD_SIZE + c].letter;
                }
                return { word };
            }

            // Check for vertical word
            let startRow = row;
            while (startRow > 0 && board[(startRow - 1) * BOARD_SIZE + col]) {
                startRow--;
            }
            let endRow = row;
            while (endRow < BOARD_SIZE - 1 && board[(endRow + 1) * BOARD_SIZE + col]) {
                endRow++;
            }

            if (startRow !== endRow) { // It's a vertical word
                let word = "";
                for (let r = startRow; r <= endRow; r++) {
                    word += board[r * BOARD_SIZE + col].letter;
                }
                return { word };
            }
            
            // It's a single letter tile not part of a larger word yet
            return { word: tile.letter };
        }


        function hasAdjacentTile(row, col, board) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of directions) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                    if (board[r * BOARD_SIZE + c]) return true;
                }
            }
            return false;
        }

        function getMoveAxis(newTiles) {
            const rows = new Set(newTiles.map(t => t.row));
            const cols = new Set(newTiles.map(t => t.col));
            if (rows.size === 1 && cols.size >= 1) return 'horizontal';
            if (cols.size === 1 && rows.size >= 1) return 'vertical';
            return 'invalid';
        }

        function getMainWord(newTiles, axis, board) {
            const startTile = newTiles[0];
            let word = [];
            if (axis === 'horizontal') {
                let currentCol = startTile.col;
                while (currentCol > 0 && getTileAt(startTile.row, currentCol - 1, newTiles, board)) {
                    currentCol--;
                }
                while (currentCol < BOARD_SIZE && getTileAt(startTile.row, currentCol, newTiles, board)) {
                    word.push(getTileAt(startTile.row, currentCol, newTiles, board));
                    currentCol++;
                }
            } else { // vertical
                let currentRow = startTile.row;
                while (currentRow > 0 && getTileAt(currentRow - 1, startTile.col, newTiles, board)) {
                    currentRow--;
                }
                while (currentRow < BOARD_SIZE && getTileAt(currentRow, startTile.col, newTiles, board)) {
                    word.push(getTileAt(currentRow, startTile.col, newTiles, board));
                    currentRow++;
                }
            }
            return word;
        }

        function getCrossWords(newTiles, mainAxis, board) {
            const crossWords = [];
            const crossAxis = mainAxis === 'horizontal' ? 'vertical' : 'horizontal';
            for (const tile of newTiles) {
                const crossWord = getMainWord([tile], crossAxis, board);
                if (crossWord.length > 1) {
                    crossWords.push(crossWord);
                }
            }
            return crossWords;
        }

    </script>
</body>
</html>
