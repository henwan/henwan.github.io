<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedWord Showdown (Single Player)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
        }
        .board-cell {
            position: relative;
        }
        .board-cell > div {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
        }
        .tile {
            cursor: grab;
            user-select: none;
            touch-action: none;
        }
        .permanent-tile {
            cursor: help;
        }
        .dragging {
            opacity: 0.5;
            cursor: grabbing;
            z-index: 1000;
        }
        .letter-tile {
            background-color: #f5f5f5;
            border: 1px solid #dcdcdc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .bonus-2l { background-color: #a0d8f0; } /* Light Blue */
        .bonus-3l { background-color: #4a90e2; color: white; } /* Dark Blue */
        .bonus-2w { background-color: #f7caca; } /* Light Pink */
        .bonus-3w { background-color: #e66767; color: white; } /* Dark Red */
        .center-star { background-color: #f7caca; }
        .center-star::before { content: '★'; font-size: 1.5rem; color: #e66767; }
        #modal-backdrop {
            transition: opacity 0.3s ease-in-out;
        }
        #modal-content {
            transition: transform 0.3s ease-in-out;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div id="game-container" class="w-full max-w-7xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-teal-700 mb-4">MedWord Showdown</h1>

        <div class="flex flex-col lg:flex-row gap-4">
            <!-- Left Panel: Game Board -->
            <div class="w-full lg:w-2/3">
                <div id="game-board" class="grid gap-0.5 bg-gray-300 rounded-lg p-1 shadow-lg aspect-square">
                    <!-- Board cells will be generated by JS -->
                </div>
            </div>

            <!-- Right Panel: Controls, Info, Score -->
            <div class="w-full lg:w-1/3 flex flex-col gap-4">
                <div id="score-board" class="bg-white p-4 rounded-lg shadow-md text-center">
                    <h2 class="text-xl font-semibold mb-2 text-gray-700">Your Score</h2>
                    <p id="player-score" class="text-4xl font-bold text-teal-600">0</p>
                </div>

                <div id="player-controls" class="bg-white p-4 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-2 text-gray-700">Your Tiles</h2>
                    <div id="tile-rack" class="flex justify-center items-center gap-1 bg-gray-200 p-2 rounded-md min-h-[60px] mb-4">
                        <!-- Player tiles will be generated by JS -->
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="play-word-btn" class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 transition-colors">Play Word</button>
                        <button id="pass-turn-btn" class="w-full bg-orange-500 text-white py-2 px-4 rounded-md hover:bg-orange-600 transition-colors">Pass Turn</button>
                        <button id="shuffle-tiles-btn" class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">Shuffle</button>
                        <button id="recall-tiles-btn" class="w-full bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600 transition-colors">Recall Tiles</button>
                    </div>
                     <button id="ai-hint-btn" class="w-full mt-2 bg-purple-600 text-white py-2 px-4 rounded-md hover:bg-purple-700 transition-colors">✨ AI Hint</button>
                </div>
                 <div class="bg-white p-4 rounded-lg shadow-md">
                    <p id="dictionary-status" class="text-center text-gray-600">Initializing medical dictionary...</p>
                    <p id="tiles-left" class="text-center font-medium text-lg mt-2">Tiles in Bag: --</p>
                     <button id="new-game-btn" class="w-full mt-4 bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 transition-colors">New Game</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="modal-backdrop" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div id="modal-content" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm text-center transform scale-95">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Game Over</h3>
            <div id="modal-body">
                <p id="modal-message" class="text-gray-700 mb-6">Player X wins!</p>
            </div>
            <button id="modal-close-btn" class="bg-teal-600 text-white py-2 px-8 rounded-lg hover:bg-teal-700 transition-colors">Close</button>
        </div>
    </div>


    <script type="module">
        // --- LOCAL GAME STATE ---
        let gameState = {};
        let medicalDictionary = new Set();

        // Game constants
        const BOARD_SIZE = 15;
        const TILE_RACK_SIZE = 7;
        const TILE_DISTRIBUTION = {
            'A': { count: 9, value: 1 }, 'B': { count: 2, value: 3 }, 'C': { count: 2, value: 3 },
            'D': { count: 4, value: 2 }, 'E': { count: 12, value: 1 }, 'F': { count: 2, value: 4 },
            'G': { count: 3, value: 2 }, 'H': { count: 2, value: 4 }, 'I': { count: 9, value: 1 },
            'J': { count: 1, value: 8 }, 'K': { count: 1, value: 5 }, 'L': { count: 4, value: 1 },
            'M': { count: 2, value: 3 }, 'N': { count: 6, value: 1 }, 'O': { count: 8, value: 1 },
            'P': { count: 2, value: 3 }, 'Q': { count: 1, value: 10 }, 'R': { count: 6, value: 1 },
            'S': { count: 4, value: 1 }, 'T': { count: 6, value: 1 }, 'U': { count: 4, value: 1 },
            'V': { count: 2, value: 4 }, 'W': { count: 2, value: 4 }, 'X': { count: 1, value: 8 },
            'Y': { count: 2, value: 4 }, 'Z': { count: 1, value: 10 }
        };
        const BONUS_SQUARES = {
            '0,0': '3w', '0,7': '3w', '0,14': '3w', '7,0': '3w', '7,14': '3w', '14,0': '3w', '14,7': '3w', '14,14': '3w',
            '1,1': '2w', '2,2': '2w', '3,3': '2w', '4,4': '2w', '1,13': '2w', '2,12': '2w', '3,11': '2w', '4,10': '2w',
            '10,4': '2w', '11,3': '2w', '12,2': '2w', '13,1': '2w', '10,10': '2w', '11,11': '2w', '12,12': '2w', '13,13': '2w',
            '1,5': '3l', '1,9': '3l', '5,1': '3l', '5,5': '3l', '5,9': '3l', '5,13': '3l', '9,1': '3l', '9,5': '3l', '9,9': '3l', '9,13': '3l', '13,5': '3l', '13,9': '3l',
            '0,3': '2l', '0,11': '2l', '2,6': '2l', '2,8': '2l', '3,0': '2l', '3,7': '2l', '3,14': '2l', '6,2': '2l', '6,6': '2l', '6,8': '2l', '6,12': '2l',
            '7,3': '2l', '7,11': '2l', '8,2': '2l', '8,6': '2l', '8,8': '2l', '8,12': '2l', '11,0': '2l', '11,7': '2l', '11,14': '2l', '12,6': '2l', '12,8': '2l', '14,3': '2l', '14,11': '2l'
        };

        // --- UI ELEMENTS ---
        const gameBoard = document.getElementById('game-board');
        const tileRack = document.getElementById('tile-rack');
        const playWordBtn = document.getElementById('play-word-btn');
        const passTurnBtn = document.getElementById('pass-turn-btn');
        const shuffleTilesBtn = document.getElementById('shuffle-tiles-btn');
        const recallTilesBtn = document.getElementById('recall-tiles-btn');
        const aiHintBtn = document.getElementById('ai-hint-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const playerScoreDisplay = document.getElementById('player-score');
        const tilesLeftDisplay = document.getElementById('tiles-left');
        const dictionaryStatus = document.getElementById('dictionary-status');

        // Modal elements
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // --- DRAG AND DROP STATE ---
        let draggedTile = null;
        let placedTiles = []; // { letter, value, originalRackIndex, row, col, element }

        // --- INITIALIZATION ---
        window.onload = () => {
            initializeDictionary();
            setupGameBoard();
            setupControlListeners();
            startNewGame();
        };
        
        function initializeDictionary() {
            dictionaryStatus.textContent = 'Loading medical dictionary...';
            const staticMedicalWords = [
                'ACNE', 'AORTA', 'ATRIUM', 'AXON', 'BILE', 'BIOPSY', 'BLOOD', 'BONE',
                'BRAIN', 'BRONCHI', 'CANCER', 'CELL', 'CLOT', 'COLON', 'CORNEA', 'COMA',
                'CYST', 'DENTAL', 'DERMA', 'DNA', 'DUCT', 'DRUG', 'EDEMA', 'ENZYME',
                'FEMUR', 'FETUS', 'FEVER', 'FIBULA', 'GENE', 'GLAND', 'GUT', 'HEART',
                'HERNIA', 'HORMONE', 'HOST', 'HYPOXIA', 'IRIS', 'JOINT', 'KELOID',
                'KIDNEY', 'LARYNX', 'LASER', 'LENS', 'LIVER', 'LOBE', 'LUNG', 'LYMPH',
                'MEDIC', 'MOLAR', 'MUCOUS', 'MUSCLE', 'NERVE', 'NEURON', 'NODE', 'ORGAN',
                'OVARY', 'PALATE', 'PANCREAS', 'PELVIS', 'PHLEGM', 'PLASMA', 'PLATELET',
                'POLLEN', 'PROBE', 'PULSE', 'PUPIL', 'RECTUM', 'RETINA', 'RNA', 'SCAB',
                'SCALP', 'SCAN', 'SCOLIOSIS', 'SEIZURE', 'SERUM', 'SINUS', 'SKIN', 'SKULL',
                'SPASM', 'SPINE', 'SPLEEN', 'SPORE', 'STENT', 'STOMACH', 'SUTURE', 'SYNAPSE',
                'TENDON', 'TESTIS', 'THROAT', 'THYMUS', 'THYROID', 'TIBIA', 'TISSUE',
                'TONSIL', 'TOXIN', 'TRACHEA', 'TUMOR', 'ULCER', 'ULNA', 'UREA', 'URETER',
                'UTERUS', 'UVULA', 'VACCINE', 'VEIN', 'VENTRICLE', 'VIRUS', 'VITAMIN', 'VOMIT',
                'WOMB', 'XRAY', 'YEAST', 'ZINC', 'ZYGOTE'
            ];
            medicalDictionary = new Set(staticMedicalWords);
            dictionaryStatus.textContent = `Medical Dictionary Ready (${medicalDictionary.size} terms)`;
        }

        function startNewGame() {
            const tileBag = createTileBag();
            gameState = {
                board: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
                tileBag: tileBag,
                player: {
                    score: 0,
                    tiles: drawTiles(tileBag, TILE_RACK_SIZE),
                    passCount: 0,
                },
                gameOver: false
            };
            placedTiles = [];
            renderGame();
        }

        // --- GAME STATE & RENDERING ---
        function renderGame() {
            if (!gameState) return;
            
            renderBoard(gameState.board);
            renderTileRack(gameState.player.tiles);
            playerScoreDisplay.textContent = gameState.player.score;
            tilesLeftDisplay.textContent = `Tiles in Bag: ${gameState.tileBag.length}`;

            if (gameState.gameOver) {
                const finalScore = gameState.player.score;
                showModal("Game Over", `<h2>Final Score: ${finalScore}</h2><p>Great game!</p>`);
            }
        }

        function renderBoard(boardState) {
            document.querySelectorAll('.permanent-tile').forEach(tile => {
                tile.removeEventListener('click', handleWordDefinitionClick);
            });

            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const row = Math.floor(i / BOARD_SIZE);
                const col = i % BOARD_SIZE;
                const cell = document.getElementById(`cell-${row}-${col}`);
                const cellContent = cell.querySelector('div');
                
                const existingTile = cellContent.querySelector('.letter-tile');
                if (existingTile) {
                    cellContent.removeChild(existingTile);
                }

                const tileData = boardState[i];
                if (tileData) {
                    const tileDiv = createTileElement(tileData.letter, tileData.value, false);
                    tileDiv.classList.remove('cursor-grab');
                    tileDiv.classList.add('permanent-tile');
                    tileDiv.dataset.row = row;
                    tileDiv.dataset.col = col;
                    tileDiv.addEventListener('click', handleWordDefinitionClick);
                    cellContent.appendChild(tileDiv);
                }
            }
        }

        function renderTileRack(tiles) {
            tileRack.innerHTML = '';
            tiles.forEach((tile, index) => {
                if (tile) {
                    const tileDiv = createTileElement(tile.letter, tile.value, true, index);
                    tileRack.appendChild(tileDiv);
                }
            });
        }
        
        // --- GAME BOARD & TILE CREATION ---
        function setupGameBoard() {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.id = `cell-${row}-${col}`;

                    const content = document.createElement('div');
                    content.className = 'border border-gray-400';
                    const key = `${row},${col}`;
                    if (row === 7 && col === 7) {
                        content.classList.add('center-star');
                    } else if (BONUS_SQUARES[key]) {
                        const bonus = BONUS_SQUARES[key];
                        content.classList.add(`bonus-${bonus}`);
                        content.textContent = bonus.toUpperCase();
                    } else {
                        content.classList.add('bg-green-50');
                    }
                    
                    cell.appendChild(content);
                    gameBoard.appendChild(cell);

                    cell.addEventListener('dragover', (e) => e.preventDefault());
                    cell.addEventListener('drop', (e) => onDrop(e, row, col));
                }
            }
        }

        function createTileElement(letter, value, isDraggable = false, rackIndex = -1) {
            const tileDiv = document.createElement('div');
            tileDiv.className = 'tile letter-tile w-10 h-10 md:w-12 md:h-12 flex items-center justify-center rounded-md text-xl font-bold relative';
            tileDiv.innerHTML = `
                ${letter}
                <span class="absolute bottom-0 right-1 text-xs font-medium">${value}</span>
            `;
            if (isDraggable) {
                tileDiv.draggable = true;
                tileDiv.dataset.letter = letter;
                tileDiv.dataset.value = value;
                tileDiv.dataset.rackIndex = rackIndex;
                tileDiv.addEventListener('dragstart', onDragStart);
                tileDiv.addEventListener('dragend', onDragEnd);
            }
            return tileDiv;
        }

        // --- DRAG & DROP HANDLERS ---
        function onDragStart(e) {
            draggedTile = {
                element: e.target,
                letter: e.target.dataset.letter,
                value: parseInt(e.target.dataset.value),
                originalRackIndex: parseInt(e.target.dataset.rackIndex)
            };
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function onDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedTile = null;
        }

        function onDrop(e, row, col) {
            e.preventDefault();
            if (!draggedTile) return;

            const cellContent = e.currentTarget.querySelector('div');
            
            if (cellContent.querySelector('.letter-tile') || gameState.board[row * BOARD_SIZE + col]) {
                return;
            }

            const newPlacedTile = { ...draggedTile, row, col };
            placedTiles.push(newPlacedTile);
            
            cellContent.appendChild(draggedTile.element);
            draggedTile.element.style.cursor = 'pointer';
            draggedTile.element.addEventListener('click', returnTileToRack);
            draggedTile = null;
        }
        
        // --- CONTROL BUTTON LOGIC ---
        function setupControlListeners() {
            recallTilesBtn.addEventListener('click', recallPlacedTiles);
            playWordBtn.addEventListener('click', handlePlayWord);
            passTurnBtn.addEventListener('click', handlePassTurn);
            shuffleTilesBtn.addEventListener('click', handleShuffle);
            aiHintBtn.addEventListener('click', handleAiHint);
            newGameBtn.addEventListener('click', startNewGame);
            modalCloseBtn.addEventListener('click', () => modalBackdrop.classList.add('hidden'));
        }

        function returnTileToRack(e) {
            const tileElement = e.currentTarget;
            const tileIndex = placedTiles.findIndex(t => t.element === tileElement);
            if (tileIndex === -1) return;

            placedTiles.splice(tileIndex, 1);
            tileRack.appendChild(tileElement);
            tileElement.removeEventListener('click', returnTileToRack);
            tileElement.style.cursor = 'grab';
        }

        function recallPlacedTiles() {
            while (placedTiles.length > 0) {
                returnTileToRack({ currentTarget: placedTiles[0].element });
            }
        }

        function handlePlayWord() {
            if (placedTiles.length === 0) {
                showModal("Invalid Move", "<p>You must place at least one tile.</p>");
                return;
            }

            const validationResult = validateMove(placedTiles, gameState.board);
            if (!validationResult.isValid) {
                showModal("Invalid Move", `<p>${validationResult.message}</p>`);
                return;
            }

            const scoreResult = calculateScore(validationResult.words, gameState.board);
            
            placedTiles.forEach(tile => {
                gameState.board[tile.row * BOARD_SIZE + tile.col] = { letter: tile.letter, value: tile.value };
            });

            const usedRackIndices = new Set(placedTiles.map(t => t.originalRackIndex));
            const remainingTiles = gameState.player.tiles.filter((_, index) => !usedRackIndices.has(index));
            
            const newTiles = drawTiles(gameState.tileBag, placedTiles.length);
            gameState.player.tiles = [...remainingTiles, ...newTiles];
            gameState.player.score += scoreResult.totalScore;
            gameState.player.passCount = 0;
            
            placedTiles.forEach(t => t.element.removeEventListener('click', returnTileToRack));
            placedTiles = [];

            if (gameState.player.tiles.length === 0 && gameState.tileBag.length === 0) {
                gameState.gameOver = true;
            }
            
            renderGame();
        }
        
        function handlePassTurn() {
            gameState.player.passCount++;
            if (gameState.player.passCount >= 2) {
                gameState.gameOver = true;
            }
            renderGame();
        }
        
        function handleShuffle() {
            if (gameState.tileBag.length < gameState.player.tiles.length) {
                showModal("Shuffle Not Possible", "<p>Not enough tiles in the bag to shuffle.</p>");
                return;
            }
            
            gameState.tileBag.push(...gameState.player.tiles);
            shuffleArray(gameState.tileBag);
            gameState.player.tiles = drawTiles(gameState.tileBag, TILE_RACK_SIZE);
            renderGame();
        }

        // --- GEMINI API FEATURES ---
        async function handleAiHint() {
            showModal("✨ AI Word Finder", `<div class="spinner"></div><p>Consulting with the AI specialist...</p>`);
            
            const playerTiles = gameState.player.tiles.map(t => t.letter).join('');
            
            let boardString = "The board is 15x15. '.' represents an empty square.\n";
            for (let r = 0; r < BOARD_SIZE; r++) {
                let rowStr = "";
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = gameState.board[r * BOARD_SIZE + c];
                    rowStr += tile ? tile.letter : ".";
                }
                boardString += rowStr + "\n";
            }

            const prompt = `You are an expert medical Scrabble player. Your task is to find a valid, high-scoring word.
            - Player's tiles: ${playerTiles}
            - Dictionary: ${[...medicalDictionary].slice(0, 50).join(', ')}... (sample)
            - Board state:\n${boardString}
            Analyze the board and the player's tiles to suggest one good move. Be concise. For example: 'Try playing VIRUS starting at row 5, column 8.'`;

            try {
                const resultText = await callGemini(prompt);
                showModal("✨ AI Word Finder", `<p class="text-left">${resultText.replace(/\n/g, '<br>')}</p>`);
            } catch (error) {
                showModal("✨ AI Error", `<p>The AI specialist is unavailable. Please try again later.</p>`);
                console.error("AI Hint Error:", error);
            }
        }

        async function handleWordDefinitionClick(e) {
            const tileElement = e.currentTarget;
            const row = parseInt(tileElement.dataset.row);
            const col = parseInt(tileElement.dataset.col);

            const { word } = findWordAt(row, col, gameState.board);
            if (!word) return;

            showModal(`Define: ${word}`, `<div class="spinner"></div><p>Looking up "${word}"...</p>`);

            const prompt = `Provide a simple, one-sentence medical definition for the word "${word}".`;
            try {
                const definition = await callGemini(prompt);
                showModal(`Define: ${word}`, `<p class="text-left">${definition}</p>`);
            } catch (error) {
                showModal("Definition Error", `<p>Could not retrieve a definition for "${word}".</p>`);
                console.error("Definition Error:", error);
            }
        }

        async function callGemini(prompt) {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }

            const result = await response.json();
            if (result.candidates && result.candidates[0].content.parts[0].text) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error("Invalid API response structure.");
            }
        }


        // --- GAME LOGIC: VALIDATION & SCORING ---
        function validateMove(newTiles, board) {
            if (newTiles.length === 0) return { isValid: false, message: "No tiles played." };

            const isFirstMove = board.every(cell => cell === null);
            if (isFirstMove) {
                if (!newTiles.some(t => t.row === 7 && t.col === 7)) {
                    return { isValid: false, message: "First word must cover the center star." };
                }
            } else {
                if (!newTiles.some(t => hasAdjacentTile(t.row, t.col, board))) {
                    return { isValid: false, message: "New words must connect to existing tiles." };
                }
            }

            const allTilesOnBoard = newTiles.map(t => ({...t, onBoard: false }));
            const moveAxis = getMoveAxis(newTiles);
            if (moveAxis === 'invalid') {
                return { isValid: false, message: "Tiles must be in a single row or column." };
            }

            const mainWordTiles = getMainWord(allTilesOnBoard, moveAxis, board);
            const mainWordString = mainWordTiles.map(t => t.letter).join('');
            if (!medicalDictionary.has(mainWordString)) {
                 return { isValid: false, message: `"${mainWordString}" is not a valid medical term.` };
            }
            if (mainWordTiles.length < 2) {
                return { isValid: false, message: "Words must be at least 2 letters long." };
            }

            const allWords = [mainWordTiles];
            const crossWords = getCrossWords(allTilesOnBoard, moveAxis, board);

            for (const word of crossWords) {
                const wordString = word.map(t => t.letter).join('');
                if (!medicalDictionary.has(wordString)) {
                    return { isValid: false, message: `"${wordString}" is not a valid medical term.` };
                }
                allWords.push(word);
            }

            return { isValid: true, words: allWords };
        }
        
        function calculateScore(words, board) {
            let totalScore = 0;
            let mainWord = words[0];
            let wordMultiplier = 1;
            let wordScore = 0;

            mainWord.forEach(tile => {
                let letterScore = tile.value;
                if (!tile.onBoard) {
                    const key = `${tile.row},${tile.col}`;
                    const bonus = BONUS_SQUARES[key] || (tile.row === 7 && tile.col === 7 ? '2w' : null);
                    if (bonus === '2l') letterScore *= 2;
                    if (bonus === '3l') letterScore *= 3;
                    if (bonus === '2w') wordMultiplier *= 2;
                    if (bonus === '3w') wordMultiplier *= 3;
                }
                wordScore += letterScore;
            });
            totalScore += wordScore * wordMultiplier;

            for (let i = 1; i < words.length; i++) {
                let crossWord = words[i];
                let crossWordScore = 0;
                let crossWordMultiplier = 1;
                crossWord.forEach(tile => {
                    let letterScore = tile.value;
                     if (!tile.onBoard) {
                        const key = `${tile.row},${tile.col}`;
                        const bonus = BONUS_SQUARES[key] || (tile.row === 7 && tile.col === 7 ? '2w' : null);
                        if (bonus === '2l') letterScore *= 2;
                        if (bonus === '3l') letterScore *= 3;
                        if (bonus === '2w') crossWordMultiplier *= 2;
                        if (bonus === '3w') crossWordMultiplier *= 3;
                    }
                    crossWordScore += letterScore;
                });
                totalScore += crossWordScore * crossWordMultiplier;
            }
            
            const newTilesCount = mainWord.filter(t => !t.onBoard).length;
            if (newTilesCount === TILE_RACK_SIZE) {
                totalScore += 50;
            }

            return { totalScore };
        }
        
        // --- UTILITY FUNCTIONS ---
        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createTileBag() {
            const bag = [];
            for (const letter in TILE_DISTRIBUTION) {
                for (let i = 0; i < TILE_DISTRIBUTION[letter].count; i++) {
                    bag.push({ letter, value: TILE_DISTRIBUTION[letter].value });
                }
            }
            shuffleArray(bag);
            return bag;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function drawTiles(tileBag, count) {
            const drawn = [];
            for (let i = 0; i < count; i++) {
                if (tileBag.length > 0) {
                    drawn.push(tileBag.pop());
                }
            }
            return drawn;
        }
        
        function showModal(title, contentHtml) {
            modalTitle.textContent = title;
            modalBody.innerHTML = contentHtml;
            modalBackdrop.classList.remove('hidden');
            modalContent.classList.remove('scale-95');
            modalContent.classList.add('scale-100');
        }

        // --- WORD FINDING HELPERS ---
        function getTileAt(row, col, newTiles, board) {
            const newTile = newTiles.find(t => t.row === row && t.col === col);
            if (newTile) return { ...newTile, onBoard: false };
            const boardIndex = row * BOARD_SIZE + col;
            if (board[boardIndex]) return { ...board[boardIndex], row, col, onBoard: true };
            return null;
        }

        function findWordAt(row, col, board) {
            const tile = board[row * BOARD_SIZE + col];
            if (!tile) return { word: null, tiles: [] };

            let startCol = col;
            while (startCol > 0 && board[row * BOARD_SIZE + (startCol - 1)]) {
                startCol--;
            }
            let endCol = col;
            while (endCol < BOARD_SIZE - 1 && board[row * BOARD_SIZE + (endCol + 1)]) {
                endCol++;
            }

            if (startCol !== endCol) {
                let word = "";
                for (let c = startCol; c <= endCol; c++) {
                    word += board[row * BOARD_SIZE + c].letter;
                }
                return { word };
            }

            let startRow = row;
            while (startRow > 0 && board[(startRow - 1) * BOARD_SIZE + col]) {
                startRow--;
            }
            let endRow = row;
            while (endRow < BOARD_SIZE - 1 && board[(endRow + 1) * BOARD_SIZE + col]) {
                endRow++;
            }

            if (startRow !== endRow) {
                let word = "";
                for (let r = startRow; r <= endRow; r++) {
                    word += board[r * BOARD_SIZE + col].letter;
                }
                return { word };
            }
            
            return { word: tile.letter };
        }


        function hasAdjacentTile(row, col, board) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of directions) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                    if (board[r * BOARD_SIZE + c]) return true;
                }
            }
            return false;
        }

        function getMoveAxis(newTiles) {
            const rows = new Set(newTiles.map(t => t.row));
            const cols = new Set(newTiles.map(t => t.col));
            if (rows.size === 1 && cols.size >= 1) return 'horizontal';
            if (cols.size === 1 && rows.size >= 1) return 'vertical';
            return 'invalid';
        }

        function getMainWord(newTiles, axis, board) {
            const startTile = newTiles[0];
            let word = [];
            if (axis === 'horizontal') {
                let currentCol = startTile.col;
                while (currentCol > 0 && getTileAt(startTile.row, currentCol - 1, newTiles, board)) {
                    currentCol--;
                }
                while (currentCol < BOARD_SIZE && getTileAt(startTile.row, currentCol, newTiles, board)) {
                    word.push(getTileAt(startTile.row, currentCol, newTiles, board));
                    currentCol++;
                }
            } else { // vertical
                let currentRow = startTile.row;
                while (currentRow > 0 && getTileAt(currentRow - 1, startTile.col, newTiles, board)) {
                    currentRow--;
                }
                while (currentRow < BOARD_SIZE && getTileAt(currentRow, startTile.col, newTiles, board)) {
                    word.push(getTileAt(currentRow, startTile.col, newTiles, board));
                    currentRow++;
                }
            }
            return word;
        }

        function getCrossWords(newTiles, mainAxis, board) {
            const crossWords = [];
            const crossAxis = mainAxis === 'horizontal' ? 'vertical' : 'horizontal';
            for (const tile of newTiles) {
                const crossWord = getMainWord([tile], crossAxis, board);
                if (crossWord.length > 1) {
                    crossWords.push(crossWord);
                }
            }
            return crossWords;
        }

    </script>
</body>
</html>
